ARM stands for adv RISC machine. First ARM processor made by Acorn Group of Computers in 1985.

# General Information

- 32-bit RISC processor
- 37 32-bit integer registers
- simple instruction set
- small core size and power efficient
- pipelined operation
- 8/16/32-bit data types
- 7 modes of operation

## 3 modes of operation of ARMv7

### Application profile
- Memory management support (MMU)
- Highest performance at low power
- Uses Jazelle-RCT (for hardware acceleration and arch support) and TrustZone (for security) for a safe and extensible system.
- ex. Cortex A5

### Real-time profile
- Protected memory (MPU)
- Low latency
- ex. Cortex R4

### Microcontroller profile
- Lowest gate count entry point
- Deterministic and predictable behavior is a key priority
- Deeply embedded use
- ex. Cortex M3

# Design Philosophy

4 major design rules:
1. Instructions:
	- reduced no. of instr classes which provide simple operations that can execute in a single cycle
	- each instr is a fixed length to allow pipelining

2. Pipelines:
	- processing of instr broken down into smaller units that are parallelly executed by pipelines

3. Registers:
	- large general-purpose register set
	- any register can contain either data or addr

4. Load-store arch:
	- separate load and store instructions to transfer data between register bank and ext. memory
	- memory accesses are costly

# Architecture

- Uses a load-store arch, so it has two instr types for transferring data in and out of the processor.
- load- copy from memory to registers
- store- copy from registers to memory
- data processing carried out solely in registers
- load and store instrs use the ALU to generate an addr to be held in the addr register and broadcast on the addr bus
- data enters through the data bus, and could either be data or an instruction

ARM arch diagram:
![[{7F1F80A4-5EFA-4205-A81C-0EFF4010C71A}.png]]

- <u>addr reg</u>: stores 32-bit memory address from which data/instr to be accessed
- <u>incrementer</u>: increments mem addr
- <u>data in/data out</u>: buffer to store 32 bit data when R/W op is performed from/into the memory
- <u>instr decode and control unit</u>:
	- instr decode translates instr before they are executed
	- operation in the processor is managed and controlled by signals generated by the control unit
- <u>register bank</u>: storage unit made of 32b registers, used in arithmetic ops, intermediate variable storage, temp addr storage etc.
- <u>ALU</u>:
	- arithmetic and logical unit
	- primary input: A bus register file
	- secondary input: B bus barrel shifter
	- result always written back to A
	- status reg flags modified by ALU outputs
- <u>barrel shifter</u>: able to shift the 32b binary pattern L/R by a specific number of positions before entering ALU, shift increases power and flexibility of many data processing operations
- <u>multiply register</u>: performs MAC(multiply accumulate), first computes product then sends it to 2nd stage which is add/accumulate

# ARM states

There are 3 states: ARM, Thumb and Jazelle
Refer [[ARM States]]

# Registers

There are upto 18 active registers: 16 data registers (r0 to r15) and 2 program status registers (CPSR and SPSR).

## Data registers:
- <u>r0 - r12</u>: Used as general purpose registers to hold data/addr.
- <U>r13 - r15</U>: Used as special function registers (SPR)
	- r13 is the **Stack Pointer**(SP) and stores the head of the stack in the current processor mode.
	- r14 is the **Link Register**(LR) and is where the core puts return addr for subroutines.
	- r15 is the **Program Counter**(PC)

## CPSR #cpsr:
- 32-bit register used to control and monitor internal operations
- Current Program Status Register
- divided into 4 fields:
	1. Control field (0-7): processor mode, state, interrupt mask bits
	2. Extension field(8-15): reserved for future use
	3. Status field(16-23): reserved for future use
	4. Flag field(24-31): contains the condition flags
- some ARM processors have extra bits allocated, like the J bit in the jazelle-enabled processors.

## SPSR #spsr:
- Saved Program Status Register
- used to store current value of CPSR when an interrupt is taken so that it can be restored post-handling of the interrupt
- each exception-handling mode can access it's own SPSR but ==User mode and System mode== do not have an SPSR because they are not exception-handling modes.

# Modes

- the processor mode determines which registers are active and the access rights to the CPSR register
- each mode has it's own stack space and a different subset of registers
- Processor mode can be of two types:
	1. Privileged: full R/W access to the CPSR
	2. Non-Privileged: only read access to the control field but R/W access to the condition flags
- there are 7 processor modes:
	1. Abort: enters into this mode when there is a failed access to memory
	2. FIQ (Fast interrupt req): this and IRQ are the 2 interrupt levels in ARM
	3. IRQ (interrupt req): this and FIQ are the 2 interrupt levels in ARM
	4. Supervisor: post-reset mode of the processor and the mode the OS kernel operates in
	5. System: special version of user mode that has full R/W access to CPSR
	6. Undefined: when processor encounters an instr that is undefined or not supported by the implementation
	7. User (non-privileged): for programs and applications

# The instruction set
- every instruction is executed conditionally
- it's possible to load/store multiple registers at once
- it's possible to combine shift and ALU operations in a single instruction
- 3-address format:
	- | opcode | destination | source 1 | source 2 |
- number rep in 0x (hex) and 0b (binary)

Refer [[ARM instr set]]